<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on</title><link>https://nickyadance.github.io/docs/web/java/</link><description>Recent content in Java on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 02 Sep 2022 13:17:19 +0800</lastBuildDate><atom:link href="https://nickyadance.github.io/docs/web/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Retrofit Okhttp</title><link>https://nickyadance.github.io/docs/web/java/retrofit_okhttp/</link><pubDate>Mon, 12 Sep 2022 18:41:01 +0800</pubDate><guid>https://nickyadance.github.io/docs/web/java/retrofit_okhttp/</guid><description>Hope that I will never bother with making http requests in Java.
@Configuration @Slf4j public class Config { public Retrofit retrofit(ObjectMapper objectMapper, CustomProperties properties) { HttpLoggingInterceptor logging = new HttpLoggingInterceptor(message -&amp;gt; { if (log.isDebugEnabled()) { log.debug(message); } }); logging.setLevel(HttpLoggingInterceptor.Level.BODY); OkHttpClient client = new OkHttpClient.Builder() .readTimeout(Duration.ofSeconds(5L)) .writeTimeout(Duration.ofSeconds(5L)) .connectTimeout(Duration.ofSeconds(3L)) .addInterceptor(chain -&amp;gt; chain.proceed(chain.request().newBuilder() .header(&amp;quot;AUTHORIZATION-NAME&amp;quot;, properties.authName) .header(&amp;quot;AUTHORIZATION-TOKEN&amp;quot;, properties.authToken) .header(&amp;quot;DATA-ENVIRONMENT&amp;quot;, properties.authEnv) .build())) .addInterceptor(logging) .build(); return new Retrofit.Builder() .baseUrl(properties.url) .client(client) .addConverterFactory(JacksonConverterFactory.create(objectMapper)) .build(); } protected interface Service { @POST(&amp;quot;/api/post&amp;quot;) Call&amp;lt;Resposne&amp;gt; saveAndSubmit(@Body Request req); @GET(&amp;quot;/api/query&amp;quot;) Call&amp;lt;Response&amp;gt; query(@Query(value = &amp;quot;param&amp;quot;) String param); } @Bean public Service service(Retrofit retrofit) { return retrofit().</description></item><item><title>Auth Filter</title><link>https://nickyadance.github.io/docs/web/java/auth_filter/</link><pubDate>Thu, 08 Sep 2022 18:48:48 +0800</pubDate><guid>https://nickyadance.github.io/docs/web/java/auth_filter/</guid><description>@Component @Slf4j @Profile(&amp;quot;!test&amp;quot;) public class GoogleAuthFilter extends OncePerRequestFilter { @Autowired GoogleAuthHolder googleAuthHolder; private void reject(HttpServletResponse response) throws IOException { response.sendError(HttpServletResponse.SC_UNAUTHORIZED, &amp;quot;unauthorized&amp;quot;); } @SneakyThrows @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) { if (request.getRequestURI().startsWith(AUTH_API_PREFIX)) { var op = Optional.ofNullable(request.getHeader(KEY_TOKEN)) .map(JWT_PATTERN::matcher) .map(m -&amp;gt; m.matches() ? m.group(1) : null) .map(tokenString -&amp;gt; { try { return VERIFIER.verify(tokenString); } catch (Exception e) { log.warn(&amp;quot;GoogleAuth verify failed: {}&amp;quot;, tokenString, e); return null; } }); if (op.</description></item><item><title>Exception Handler</title><link>https://nickyadance.github.io/docs/web/java/exception_handler/</link><pubDate>Thu, 08 Sep 2022 18:47:33 +0800</pubDate><guid>https://nickyadance.github.io/docs/web/java/exception_handler/</guid><description>@RestControllerAdvice @Slf4j public class GlobalExceptionHandler { @ExceptionHandler({BusinessException.class}) protected Response&amp;lt;Object&amp;gt; handleBusinessException(Exception ex, WebRequest request) throws Exception { log.error(&amp;quot;business error&amp;quot;, ex); if (ex instanceof BusinessException be) { return Response.fail(be.code, be.message); } else if (ex.getCause() instanceof BusinessException cbe) { return Response.fail(cbe.code, cbe.message); } else { throw ex; } } }</description></item><item><title>Request Correlation</title><link>https://nickyadance.github.io/docs/web/java/request_correlation/</link><pubDate>Thu, 08 Sep 2022 18:43:19 +0800</pubDate><guid>https://nickyadance.github.io/docs/web/java/request_correlation/</guid><description>Correlate request before and after Spring processing.
Add request_id to request context Add request_id to log4j MDC Add request_id to response Before request
@Configuration @Slf4j public class RequestCorrelationConfig { public static final String KEY_REQUEST_ID = &amp;quot;X-Request-Id&amp;quot;; public static final String KEY_START_TIME = &amp;quot;KEY_START_TIME&amp;quot;; public static class RequestLoggingWithTimeFilter extends CommonsRequestLoggingFilter { @Override protected boolean shouldLog(HttpServletRequest request) { return true; } @Override protected void beforeRequest(HttpServletRequest request, String message) { String requestId = request.</description></item><item><title>MDCThreadpool</title><link>https://nickyadance.github.io/docs/web/java/mdcthreadpool/</link><pubDate>Thu, 08 Sep 2022 18:37:05 +0800</pubDate><guid>https://nickyadance.github.io/docs/web/java/mdcthreadpool/</guid><description>Useful thread pool wrapper to pass MDC context across threads.
public class MDCThreadPoolExecutor implements ExecutorService { protected ExecutorService executorService; MDCThreadPoolExecutor() { } public MDCThreadPoolExecutor( int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue) { this.executorService = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); } public MDCThreadPoolExecutor( int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory) { this.executorService = new ThreadPoolExecutor( corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory); } public MDCThreadPoolExecutor( int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, RejectedExecutionHandler handler) { this.</description></item></channel></rss>