<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on</title><link>https://nickyadance.github.io/docs/lang/golang/</link><description>Recent content in Golang on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 07 Sep 2022 21:42:59 +0800</lastBuildDate><atom:link href="https://nickyadance.github.io/docs/lang/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Distributed Lock</title><link>https://nickyadance.github.io/docs/lang/golang/distributed_lock/</link><pubDate>Wed, 07 Sep 2022 21:44:47 +0800</pubDate><guid>https://nickyadance.github.io/docs/lang/golang/distributed_lock/</guid><description>Easy to use Etcd distributed lock, some design pattern are worth thinking.
func (child *Children) WantsToPlay(computer *Computer, timeToEat *sync.WaitGroup) error { defer timeToEat.Done() fmt.Printf(&amp;quot;%s wants to play\n&amp;quot;, child.name) session, err := concurrency.NewSession(computer.cpu, concurrency.WithTTL(10000)) if err != nil { return err } defer session.Close() seat := concurrency.NewMutex(session, computer.name) if child.isPatient { if err := seat.Lock(context.TODO()); err != nil { return err } } else { if err := seat.TryLock(context.TODO()); err != nil { if err == concurrency.</description></item></channel></rss>