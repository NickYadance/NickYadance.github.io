<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithm on</title><link>https://nickyadance.github.io/docs/algorithm/</link><description>Recent content in Algorithm on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Mon, 17 Oct 2022 17:20:44 +0800</lastBuildDate><atom:link href="https://nickyadance.github.io/docs/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>DP</title><link>https://nickyadance.github.io/docs/algorithm/dp/</link><pubDate>Tue, 21 Feb 2023 21:47:11 +0800</pubDate><guid>https://nickyadance.github.io/docs/algorithm/dp/</guid><description>Complete walkthrough of DP: cutting problem # The cutting problem is to get the max profit while cutting the stick of length n $P(n)$, into many parts with any length, each length of part have its own price $p(i)$.
DP and divide&amp;amp;conquer # The divide&amp;amp;conquer divides the problem into subproblems and merge their results, all the subproblems never repeat nor overlap.
The DP(dynamic programming) divides the problem into subproblems and some subproblems can repeat but not overlap.</description></item><item><title>Linearsort</title><link>https://nickyadance.github.io/docs/algorithm/linearsort/</link><pubDate>Fri, 17 Feb 2023 20:36:31 +0800</pubDate><guid>https://nickyadance.github.io/docs/algorithm/linearsort/</guid><description>Decision tree in sort algorithms # The decision tree can be used to describe all effective sort algorithms based on:
Each leaf node is one possible answer to a sort algorithm Leaf node num &amp;gt;= $N!,N=size$, so the algorithm can get all sorts orders O(algo) = length of longest_simple_path in decision tree Countingsort # The countingsort is easy to understand but also easy to misunderstand. The countingsort, based on the fact that the input number is limited to $N$, counts all numbers and relay them back in sorted order.</description></item><item><title>Quicksort</title><link>https://nickyadance.github.io/docs/algorithm/quick_sort/</link><pubDate>Sat, 11 Feb 2023 21:47:50 +0800</pubDate><guid>https://nickyadance.github.io/docs/algorithm/quick_sort/</guid><description>Divide and Conquer # QuickSort(A, l, r): * if l &amp;lt; r : * p = Partition(A, l, r) * QuickSort(A, l, p - 1) * QuickSort(A, p + 1, r) Hoare Partition and Lomuto Partition # hoares-vs-lomuto-partition-scheme-quicksort
In Lomuto partition, the array is divided into 4 parts. For $A[l, r), i \in [l, r), j \in [l, r), x=A[r - 1]$ $$ \begin{cases} V: &amp;amp;T(j)= \begin{cases} &amp;amp;k \in [l, i), A[k] &amp;lt;= x \\ &amp;amp;k \in (i, j), A[k] &amp;gt; x \\ &amp;amp;k \in [j, r), A[k] \ ?</description></item><item><title>Heapsort</title><link>https://nickyadance.github.io/docs/algorithm/heap_sort/</link><pubDate>Sat, 11 Feb 2023 21:47:45 +0800</pubDate><guid>https://nickyadance.github.io/docs/algorithm/heap_sort/</guid><description>Tree representation of array # The array(A) can be represented with a binary tree with A[0] as root, A[1] as left child of root, A[2] as right child of root&amp;hellip; Heapify # The first step of heap sort is to build a heap from an array by running heapify recursively.
The heapify(max) process is to retain the follow variant. For $tree(root) $ $$ \begin{cases} &amp;amp;root.val &amp;gt;= any(tree(root.left)) \\ &amp;amp;root.val &amp;gt;= any(tree(root.</description></item><item><title>Max Subarray</title><link>https://nickyadance.github.io/docs/algorithm/max_subarray/</link><pubDate>Thu, 12 Jan 2023 16:15:36 +0800</pubDate><guid>https://nickyadance.github.io/docs/algorithm/max_subarray/</guid><description>Equivalent Stock Selling Problem # The max subarray problem can be easily transferred into stock selling problem, in which we need to find the max profit with buying and selling for only once. Take following stock price array for example $$[1\ 3\ 7\ 5\ 8\ 2]$$ The equivalent input for max subarray is $$[2\ 4\ -2\ 3\ -6]$$ The answer is 7 for both problems.
Divide and Conquer # As in mergesort, we follow the 3 procedures of divide and conquer.</description></item><item><title>Reverse Pair</title><link>https://nickyadance.github.io/docs/algorithm/reverse_pair/</link><pubDate>Wed, 11 Jan 2023 17:34:48 +0800</pubDate><guid>https://nickyadance.github.io/docs/algorithm/reverse_pair/</guid><description> What&amp;rsquo;s the relationship between O(n) of insertion sort and reverse pair ?
A: Equal.
class ReversePair { public static int reversePair(int[] A, int l, int r) { if (r - l &amp;gt; 1) { int mid = (r + l) / 2; int n = 0; for (int i = l; i &amp;lt; mid; i++) { for (int j = mid; j &amp;lt; r; j++) { if (A[i] &amp;gt; A[j]) ++n; } } return n + reversePair(A, l, mid) + reversePair(A, mid, r); } return 0; } }</description></item><item><title>Mergesort</title><link>https://nickyadance.github.io/docs/algorithm/mergesort/</link><pubDate>Wed, 11 Jan 2023 15:27:52 +0800</pubDate><guid>https://nickyadance.github.io/docs/algorithm/mergesort/</guid><description>Divide And Conquer # Divide: divide the original problem to several smaller sub problems Resolve: resolve sub problems if they are small enough, or else goto step1 Conquer: merge the result of sub problems Merge Sort # MergeSort(A,l,r): if l &amp;lt; r: m=(l+r)/2 MergeSort(A,l,m) MergeSort(A,m,r) Merge(A,l,m,r) Analysis # For merge sort, when $n=2^n$ $$ T(n)= \begin{cases} 1, &amp;amp;n=1 \\ 2T(n/2)+cn &amp;amp;n&amp;gt;1 \\ \end{cases} $$ The recursive tree of the merge sort complexity</description></item><item><title>Insertion Sort</title><link>https://nickyadance.github.io/docs/algorithm/insertionsort/</link><pubDate>Wed, 11 Jan 2023 14:39:50 +0800</pubDate><guid>https://nickyadance.github.io/docs/algorithm/insertionsort/</guid><description>Loop Variant # Let&amp;rsquo;s learn about how to prove the algorithm right with Loop Variant, which contains 4 parts: $$ \begin{cases} Variant(V): &amp;amp;T(i) \\ Start(S): &amp;amp;T(0) \\ Loop(L): &amp;amp;T(i+1)=f(T(i)) \\ End(E): &amp;amp;Answer=f(T(n)) \\ \end{cases} $$
For insertion sort $$ \begin{cases} V: &amp;amp;T(i)=sorted(A[0,i]) \\ S: &amp;amp;T(0)=sorted(A[0,0]) \\ L: &amp;amp;T(i+1)=orderd\_insertion(T(i), A[i+1]) \\ E: &amp;amp;Answer=T(n)=sorted(A[0,n]) \\ \end{cases} $$
Pseudocode
InsertionSort(A): for i=1 to A.length: j=i-1 while A[j]&amp;gt;A[i] and j &amp;gt;= 0: A[j+1]=A[j] j=j-1 A[j+1]=A[i] Analysis # For the best condition when A is ascending sorted $$t_j=1,\ T(n)=an+b$$ For the worst condition when A is descending sorted $$t_j=j,\ T(n)=an^2+bn+c$$</description></item><item><title>Binarysearch</title><link>https://nickyadance.github.io/docs/algorithm/binarysearch/</link><pubDate>Wed, 11 Jan 2023 10:13:09 +0800</pubDate><guid>https://nickyadance.github.io/docs/algorithm/binarysearch/</guid><description>lower_bound # lower_bound of $x$ in non-descending $array[l, r)$ is the leftmost index to insert $x$ while keeping order.
To find the lower_bound with binary-search, keep loop invariant as below during iterations. $$ loop\ invariant \begin{cases} 0.\ [l, r), &amp;amp;l&amp;lt;r \\ 1.\ a[i]&amp;lt;=a[j], &amp;amp;l&amp;lt;=i&amp;lt;j&amp;lt;r \\ 2.\ array[l_0]&amp;lt;array[l], &amp;amp;l_0&amp;lt;l \\ 3.^*\ array[r_0]&amp;gt;=array[r], &amp;amp;r_0&amp;gt;=r \\ \end{cases} $$ The invariant $3.$ can be inferred from $0,1,2$.
Basic implementation in Java.
class BinarySearch { public static int lower_bound(int[] a, int target) { int l = 0, r = a.</description></item><item><title>Simrank</title><link>https://nickyadance.github.io/docs/algorithm/simrank/</link><pubDate>Thu, 08 Dec 2022 16:22:58 +0800</pubDate><guid>https://nickyadance.github.io/docs/algorithm/simrank/</guid><description/></item></channel></rss>