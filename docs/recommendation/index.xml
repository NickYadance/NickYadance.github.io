<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Recommendation on</title><link>https://nickyadance.github.io/docs/recommendation/</link><description>Recent content in Recommendation on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Mon, 17 Oct 2022 17:20:44 +0800</lastBuildDate><atom:link href="https://nickyadance.github.io/docs/recommendation/index.xml" rel="self" type="application/rss+xml"/><item><title>Max Subarray</title><link>https://nickyadance.github.io/docs/recommendation/max_subarray/</link><pubDate>Thu, 12 Jan 2023 16:15:36 +0800</pubDate><guid>https://nickyadance.github.io/docs/recommendation/max_subarray/</guid><description>Equivalent Stock Selling Problem # The max subarray problem can be easily transferred into stock selling problem, in which we need to find the max profit with buying and selling for only once. Take following stock price array for example $$[1\ 3\ 7\ 5\ 8\ 2]$$ The equivalent input for max subarray is $$[2\ 4\ -2\ 3\ -6]$$ The answer is 7 for both problems.
Divide and Conquer # As in mergesort, we follow the 3 procedures of divide and conquer.</description></item><item><title>Reverse Pair</title><link>https://nickyadance.github.io/docs/recommendation/reverse_pair/</link><pubDate>Wed, 11 Jan 2023 17:34:48 +0800</pubDate><guid>https://nickyadance.github.io/docs/recommendation/reverse_pair/</guid><description> What&amp;rsquo;s the relationship between O(n) of insertion sort and reverse pair ?
A: Equal.
class ReversePair { public static int reversePair(int[] A, int l, int r) { if (r - l &amp;gt; 1) { int mid = (r + l) / 2; int n = 0; for (int i = l; i &amp;lt; mid; i++) { for (int j = mid; j &amp;lt; r; j++) { if (A[i] &amp;gt; A[j]) ++n; } } return n + reversePair(A, l, mid) + reversePair(A, mid, r); } return 0; } }</description></item><item><title>Mergesort</title><link>https://nickyadance.github.io/docs/recommendation/mergesort/</link><pubDate>Wed, 11 Jan 2023 15:27:52 +0800</pubDate><guid>https://nickyadance.github.io/docs/recommendation/mergesort/</guid><description>Divide And Conquer # Divide: divide the original problem to several smaller sub problems Resolve: resolve sub problems if they are small enough, or else goto step1 Conquer: merge the result of sub problems Merge Sort # MergeSort(A,l,r): if l &amp;lt; r: m=(l+r)/2 MergeSort(A,l,m) MergeSort(A,m,r) Merge(A,l,m,r) Analysis # For merge sort, when $n=2^n$ $$ T(n)= \begin{cases} 1, &amp;amp;n=1 \\ 2T(n/2)+cn &amp;amp;n&amp;gt;1 \\ \end{cases} $$ The recursive tree of the merge sort complexity</description></item><item><title>Insertionsort</title><link>https://nickyadance.github.io/docs/recommendation/insertionsort/</link><pubDate>Wed, 11 Jan 2023 14:39:50 +0800</pubDate><guid>https://nickyadance.github.io/docs/recommendation/insertionsort/</guid><description>Loop Variant # Let&amp;rsquo;s learn about how to prove the algorithm right with Loop Variant, which contains 4 parts: $$ \begin{cases} Variant(V): &amp;amp;T(i) \\ Start(S): &amp;amp;T(0) \\ Loop(L): &amp;amp;T(i+1)=f(T(i)) \\ End(E): &amp;amp;Answer=f(T(n)) \\ \end{cases} $$
For insertion sort $$ \begin{cases} V: &amp;amp;T(i)=sorted(A[0,i]) \\ S: &amp;amp;T(0)=sorted(A[0,0]) \\ L: &amp;amp;T(i+1)=orderd\_insertion(T(i), A[i+1]) \\ E: &amp;amp;Answer=T(n)=sorted(A[0,n]) \\ \end{cases} $$
Pseudocode
InsertionSort(A): for i=1 to A.length: j=i-1 while A[j]&amp;gt;A[i] and j &amp;gt;= 0: A[j+1]=A[j] j=j-1 A[j+1]=A[i] Analysis # For the best condition when A is ascending sorted $$t_j=1,\ T(n)=an+b$$ For the worst condition when A is descending sorted $$t_j=j,\ T(n)=an^2+bn+c$$</description></item><item><title>Binarysearch</title><link>https://nickyadance.github.io/docs/recommendation/binarysearch/</link><pubDate>Wed, 11 Jan 2023 10:13:09 +0800</pubDate><guid>https://nickyadance.github.io/docs/recommendation/binarysearch/</guid><description>lower_bound # lower_bound of $x$ in non-descending $array[l, r)$ is the leftmost index to insert $x$ while keeping order.
To find the lower_bound with binary-search, keep loop invariant as below during iterations. $$ loop\ invariant \begin{cases} 0.\ [l, r), &amp;amp;l&amp;lt;r \\ 1.\ a[i]&amp;lt;=a[j], &amp;amp;l&amp;lt;=i&amp;lt;j&amp;lt;r \\ 2.\ array[l_0]&amp;lt;array[l], &amp;amp;l_0&amp;lt;l \\ 3.^*\ array[r_0]&amp;gt;=array[r], &amp;amp;r_0&amp;gt;=r \\ \end{cases} $$ The invariant $3.$ can be inferred from $0,1,2$.
Basic implementation in Java.
class BinarySearch { public static int lower_bound(int[] a, int target) { int l = 0, r = a.</description></item><item><title>Simrank</title><link>https://nickyadance.github.io/docs/recommendation/simrank/</link><pubDate>Thu, 08 Dec 2022 16:22:58 +0800</pubDate><guid>https://nickyadance.github.io/docs/recommendation/simrank/</guid><description/></item><item><title>Swing</title><link>https://nickyadance.github.io/docs/recommendation/swing/</link><pubDate>Thu, 17 Nov 2022 15:14:27 +0800</pubDate><guid>https://nickyadance.github.io/docs/recommendation/swing/</guid><description/></item><item><title>Icf</title><link>https://nickyadance.github.io/docs/recommendation/icf/</link><pubDate>Mon, 17 Oct 2022 17:21:21 +0800</pubDate><guid>https://nickyadance.github.io/docs/recommendation/icf/</guid><description>Chinese special
矩阵 # 转置矩阵 把矩阵A的行和列互相交换所产生的矩阵称为A的转置矩阵($A^T$) 矩阵相乘 如A是m×n矩阵，B是n×p矩阵，它们的乘积C是一个m×p矩阵 $$ C = AB, c_{ij}=\sum^n_{r=1}{a_{ir}b_{rj}} $$ 理解矩阵相乘的意义 $$ 3x + 7y = 49 $$ $$ 2x + 4y = 54 $$ 的矩阵表现形式为 $$ \begin{pmatrix} 3 &amp;amp; 7 \\ 2 &amp;amp; 4 \end{pmatrix} \ * \begin{pmatrix} x \\ y \end{pmatrix} = \begin{pmatrix} 49 \\ 54 \end{pmatrix}$$ 特征值和特征向量 n×n的方块矩阵A的一个特征值和对应特征向量是满足以下方程的标量以及非零向量。其中v为特征向量，$\lambda$为特征值。 $$ Av=\lambda v $$ 余弦相似度 # 设坐标点 $(x_1,y_1), (x_2,y_2)$ $$ cos(\theta)=\frac {a^2+b^2-c^2}{2ab}, c=\sqrt {(x_1-x_2)^2+(y_1-y_2)^2} $$ $$ cos(\theta)=\frac {x_1 * x_2+y_1 * y_2}{\sqrt {x_1^2+y_1^2}*\sqrt{x_2^2+y_2^2}} $$ 推广到多个点 $$ cos(\theta)=\frac {\sum{x_i * y_i}}{\sqrt{\sum{x_i^2}} * \sqrt{\sum{y_i^2}}} = \frac {\vec{a} * \vec{b}}{|\vec{a}| * |\vec{b}|}$$</description></item></channel></rss>