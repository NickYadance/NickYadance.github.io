<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><meta name="description" content="The blog of a programmer who enjoys learning and building things."/><meta property="og:image" content="https://og-image.vercel.app/WuYi&#x27;s%20Blog.png?theme=light&amp;md=0&amp;fontSize=75px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><meta name="og:title" content="WuYi&#x27;s Blog"/><meta name="twitter:card" content="summary_large_image"/><title>理解动态规划：从切钢管开始</title><meta name="next-head-count" content="8"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/11f0b3113f1fffe8.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/11f0b3113f1fffe8.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/327bdfcd3e98582f.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/327bdfcd3e98582f.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-445a5fe7cadeec28.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-bbecb7d54330d002.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-6e8ee6ae7cc0a14c.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-25345a12794bca3a.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/759-ab296d94798b3fbe.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-309d8f82ce6c61df.js" defer="" crossorigin=""></script><script src="/_next/static/uFVsFydzUSYwDaGmMATFd/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/uFVsFydzUSYwDaGmMATFd/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="layout_container__FUycR"><header class="layout_header__SFlEE"></header><main><article><h1 class="utils_headingXl__zlq1q">理解动态规划：从切钢管开始</h1><div class="utils_lightText__B_gv3"><time dateTime="2023-11-13">November 13, 2023</time></div><div><p>动态规划(dynamic programming)是一种分治算法，可以解决一类拥有特定性质的问题，针对这些问题，动态规划提供一种高效的解决思路。特定性质包括两点：</p>
<ol>
<li>重复子问题</li>
<li>最优子结构</li>
</ol>
<p>两种性质按字面意义理解都不难，1，有被重复处理的子问题；2，当父问题的解是最优时，子问题也是最优，具体问题中的难点是发现问题具有这两种性质，并做出子问题的定义。
本文以切钢管问题为例子，介绍动态规划的问题解决原理和编码模板。</p>
<p>钢管问题：已知长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span>的钢管的的售价为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">p(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mclose">)</span></span></span></span>，现在可将长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span>的钢管切成任意段，求所有片段的售价总和最大值。</p>
<p>直观的看，对于长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span>的钢管，我们可以分别尝试在长度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1,2,...,n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mpunct">,</span><span class="mord mathit">n</span></span></span></span>的位置“砍一刀”得到一个切分方案，得到一个递归式。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>M</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>p</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>+</mo><mi>P</mi><mo>(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>)</mo><mo>)</mo><mo separator="true">,</mo><mi>i</mi><mo>∈</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">P(n)=Max(p(i) + P(n-i)), i \in [1,n]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit">a</span><span class="mord mathit">x</span><span class="mopen">(</span><span class="mord mathit">p</span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathit">i</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord mathit">i</span><span class="mrel">∈</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit">n</span><span class="mclose">]</span></span></span></span></span></p>
<p>画出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mn>4</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">P(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathrm">4</span><span class="mclose">)</span></span></span></span>的递归树，树中有多个重复的子节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo separator="true">,</mo><mi>P</mi><mo>(</mo><mn>2</mn><mo>)</mo><mo separator="true">,</mo><mi>P</mi><mo>(</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">P(1),P(2),P(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathrm">0</span><span class="mclose">)</span></span></span></span>，说明问题满足动态规划的性质之一：<strong>重复子问题</strong>。</p>
<p><img src="/images/dp_cutting_recursive_tree.png" alt="dp_cutting_recursive_tree.png"></p>
<p>切钢管问题中，每次切分后只会产生一个不重叠的子问题，可以通过<strong>cut-paste</strong>方法进行反证最优子结构。对于一般
的动态规划问题，也可以通过这种方式进行证明。</p>
<p>假设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>p</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>+</mo><mi>P</mi><mo>(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">P(n)=p(i)+P(n-i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit">p</span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathit">i</span><span class="mclose">)</span></span></span></span>为最优解， 而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">P(n-i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathit">i</span><span class="mclose">)</span></span></span></span>不是最优解，那么会存在另外一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mn>1</mn><mo>(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">P1(n-i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord mathrm">1</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathit">i</span><span class="mclose">)</span></span></span></span>，使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mn>1</mn><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>p</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>+</mo><mi>P</mi><mn>1</mn><mo>(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">P1(n)=p(i)+P1(n-i)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord mathrm">1</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit">p</span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord mathrm">1</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathit">i</span><span class="mclose">)</span></span></span></span>为最优解，与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">P(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>为最优解矛盾。</p>
<p>确定问题的递归式和最优子结构性质后，就可以自底向上递推得出最优解。</p>
<pre><code class="hljs language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CuttingProblem</span><span class="hljs-params">(price []<span class="hljs-type">int</span>, length <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> {
	dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, length+<span class="hljs-number">1</span>)
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= length; i++ {
		<span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= i; j++ {
			dp[i] = max(dp[i], price[j]+dp[i-j])
		}
	}

	<span class="hljs-keyword">return</span> dp[length]
}
</code></pre>
<p>另一个问题是<strong>最优解路径</strong>。由于具有<strong>最优子结构</strong>性质，每个问题的最优解都是由当前问题的解和子问题最优解组成，因此我们
可以<strong>从后向前回溯子问题</strong>，将所有解拼接起来得到最优解路径。</p>
<pre><code class="hljs language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Path</span><span class="hljs-params">(price, cuttingPoint []<span class="hljs-type">int</span>, length <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> {
	<span class="hljs-keyword">if</span> length &gt; <span class="hljs-number">0</span> {
		<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%s+%d[%d]&quot;</span>, Path(price, cuttingPoint, length-cuttingPoint[length]), cuttingPoint[length], price[cuttingPoint[length]])
	}
	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CuttingProblem</span><span class="hljs-params">(price []<span class="hljs-type">int</span>, length <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> {
	dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, length+<span class="hljs-number">1</span>)
	cuttingPoint := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, length+<span class="hljs-number">1</span>)
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= length; i++ {
		<span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= i; j++ {
			<span class="hljs-keyword">if</span> price[j]+dp[i-j] &gt; dp[i] {
				dp[i] = price[j] + dp[i-j]
				cuttingPoint[i] = j
			}
		}
	}

	fmt.Println(Path(price, cuttingPoint, length))

	<span class="hljs-keyword">return</span> dp[length]
}
</code></pre>
<blockquote>
<p><a href="https://jingyuexing.github.io/Ebook/Algorithm/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA.pdf">算法导论</a></p>
</blockquote>
</div></article></main><div class="layout_backToHome__D9QFr"><a href="/">← Back</a></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"postData":{"id":"dp","contentHtml":"\u003cp\u003e动态规划(dynamic programming)是一种分治算法，可以解决一类拥有特定性质的问题，针对这些问题，动态规划提供一种高效的解决思路。特定性质包括两点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e重复子问题\u003c/li\u003e\n\u003cli\u003e最优子结构\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e两种性质按字面意义理解都不难，1，有被重复处理的子问题；2，当父问题的解是最优时，子问题也是最优，具体问题中的难点是发现问题具有这两种性质，并做出子问题的定义。\n本文以切钢管问题为例子，介绍动态规划的问题解决原理和编码模板。\u003c/p\u003e\n\u003cp\u003e钢管问题：已知长度为\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003ei\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003ei\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"strut\" style=\"height:0.65952em;\"\u003e\u003c/span\u003e\u003cspan class=\"strut bottom\" style=\"height:0.65952em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"base textstyle uncramped\"\u003e\u003cspan class=\"mord mathit\"\u003ei\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e的钢管的的售价为\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003ep\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmi\u003ei\u003c/mi\u003e\u003cmo\u003e)\u003c/mo\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003ep(i)\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"strut\" style=\"height:0.75em;\"\u003e\u003c/span\u003e\u003cspan class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"base textstyle uncramped\"\u003e\u003cspan class=\"mord mathit\"\u003ep\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003ei\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e，现在可将长度为\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003en\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003en\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"strut\" style=\"height:0.43056em;\"\u003e\u003c/span\u003e\u003cspan class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"base textstyle uncramped\"\u003e\u003cspan class=\"mord mathit\"\u003en\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e的钢管切成任意段，求所有片段的售价总和最大值。\u003c/p\u003e\n\u003cp\u003e直观的看，对于长度为\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003en\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003en\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"strut\" style=\"height:0.43056em;\"\u003e\u003c/span\u003e\u003cspan class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"\u003e\u003c/span\u003e\u003cspan class=\"base textstyle uncramped\"\u003e\u003cspan class=\"mord mathit\"\u003en\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e的钢管，我们可以分别尝试在长度\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmn\u003e1\u003c/mn\u003e\u003cmo separator=\"true\"\u003e,\u003c/mo\u003e\u003cmn\u003e2\u003c/mn\u003e\u003cmo separator=\"true\"\u003e,\u003c/mo\u003e\u003cmi mathvariant=\"normal\"\u003e.\u003c/mi\u003e\u003cmi mathvariant=\"normal\"\u003e.\u003c/mi\u003e\u003cmi mathvariant=\"normal\"\u003e.\u003c/mi\u003e\u003cmo separator=\"true\"\u003e,\u003c/mo\u003e\u003cmi\u003en\u003c/mi\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003e1,2,...,n\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"strut\" style=\"height:0.64444em;\"\u003e\u003c/span\u003e\u003cspan class=\"strut bottom\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"\u003e\u003c/span\u003e\u003cspan class=\"base textstyle uncramped\"\u003e\u003cspan class=\"mord mathrm\"\u003e1\u003c/span\u003e\u003cspan class=\"mpunct\"\u003e,\u003c/span\u003e\u003cspan class=\"mord mathrm\"\u003e2\u003c/span\u003e\u003cspan class=\"mpunct\"\u003e,\u003c/span\u003e\u003cspan class=\"mord mathrm\"\u003e.\u003c/span\u003e\u003cspan class=\"mord mathrm\"\u003e.\u003c/span\u003e\u003cspan class=\"mord mathrm\"\u003e.\u003c/span\u003e\u003cspan class=\"mpunct\"\u003e,\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003en\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e的位置“砍一刀”得到一个切分方案，得到一个递归式。\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"katex-display\"\u003e\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eP\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmo\u003e)\u003c/mo\u003e\u003cmo\u003e=\u003c/mo\u003e\u003cmi\u003eM\u003c/mi\u003e\u003cmi\u003ea\u003c/mi\u003e\u003cmi\u003ex\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmi\u003ep\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmi\u003ei\u003c/mi\u003e\u003cmo\u003e)\u003c/mo\u003e\u003cmo\u003e+\u003c/mo\u003e\u003cmi\u003eP\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmo\u003e−\u003c/mo\u003e\u003cmi\u003ei\u003c/mi\u003e\u003cmo\u003e)\u003c/mo\u003e\u003cmo\u003e)\u003c/mo\u003e\u003cmo separator=\"true\"\u003e,\u003c/mo\u003e\u003cmi\u003ei\u003c/mi\u003e\u003cmo\u003e∈\u003c/mo\u003e\u003cmo\u003e[\u003c/mo\u003e\u003cmn\u003e1\u003c/mn\u003e\u003cmo separator=\"true\"\u003e,\u003c/mo\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmo\u003e]\u003c/mo\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eP(n)=Max(p(i) + P(n-i)), i \\in [1,n]\n\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"strut\" style=\"height:0.75em;\"\u003e\u003c/span\u003e\u003cspan class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"base displaystyle textstyle uncramped\"\u003e\u003cspan class=\"mord mathit\" style=\"margin-right:0.13889em;\"\u003eP\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003en\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003cspan class=\"mrel\"\u003e=\u003c/span\u003e\u003cspan class=\"mord mathit\" style=\"margin-right:0.10903em;\"\u003eM\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003ea\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003ex\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003ep\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003ei\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003cspan class=\"mbin\"\u003e+\u003c/span\u003e\u003cspan class=\"mord mathit\" style=\"margin-right:0.13889em;\"\u003eP\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003en\u003c/span\u003e\u003cspan class=\"mbin\"\u003e−\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003ei\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003cspan class=\"mpunct\"\u003e,\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003ei\u003c/span\u003e\u003cspan class=\"mrel\"\u003e∈\u003c/span\u003e\u003cspan class=\"mopen\"\u003e[\u003c/span\u003e\u003cspan class=\"mord mathrm\"\u003e1\u003c/span\u003e\u003cspan class=\"mpunct\"\u003e,\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003en\u003c/span\u003e\u003cspan class=\"mclose\"\u003e]\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e画出\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eP\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmn\u003e4\u003c/mn\u003e\u003cmo\u003e)\u003c/mo\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eP(4)\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"strut\" style=\"height:0.75em;\"\u003e\u003c/span\u003e\u003cspan class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"base textstyle uncramped\"\u003e\u003cspan class=\"mord mathit\" style=\"margin-right:0.13889em;\"\u003eP\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathrm\"\u003e4\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e的递归树，树中有多个重复的子节点\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eP\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmn\u003e1\u003c/mn\u003e\u003cmo\u003e)\u003c/mo\u003e\u003cmo separator=\"true\"\u003e,\u003c/mo\u003e\u003cmi\u003eP\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmn\u003e2\u003c/mn\u003e\u003cmo\u003e)\u003c/mo\u003e\u003cmo separator=\"true\"\u003e,\u003c/mo\u003e\u003cmi\u003eP\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmn\u003e0\u003c/mn\u003e\u003cmo\u003e)\u003c/mo\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eP(1),P(2),P(0)\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"strut\" style=\"height:0.75em;\"\u003e\u003c/span\u003e\u003cspan class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"base textstyle uncramped\"\u003e\u003cspan class=\"mord mathit\" style=\"margin-right:0.13889em;\"\u003eP\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathrm\"\u003e1\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003cspan class=\"mpunct\"\u003e,\u003c/span\u003e\u003cspan class=\"mord mathit\" style=\"margin-right:0.13889em;\"\u003eP\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathrm\"\u003e2\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003cspan class=\"mpunct\"\u003e,\u003c/span\u003e\u003cspan class=\"mord mathit\" style=\"margin-right:0.13889em;\"\u003eP\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathrm\"\u003e0\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e，说明问题满足动态规划的性质之一：\u003cstrong\u003e重复子问题\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/dp_cutting_recursive_tree.png\" alt=\"dp_cutting_recursive_tree.png\"\u003e\u003c/p\u003e\n\u003cp\u003e切钢管问题中，每次切分后只会产生一个不重叠的子问题，可以通过\u003cstrong\u003ecut-paste\u003c/strong\u003e方法进行反证最优子结构。对于一般\n的动态规划问题，也可以通过这种方式进行证明。\u003c/p\u003e\n\u003cp\u003e假设\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eP\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmo\u003e)\u003c/mo\u003e\u003cmo\u003e=\u003c/mo\u003e\u003cmi\u003ep\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmi\u003ei\u003c/mi\u003e\u003cmo\u003e)\u003c/mo\u003e\u003cmo\u003e+\u003c/mo\u003e\u003cmi\u003eP\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmo\u003e−\u003c/mo\u003e\u003cmi\u003ei\u003c/mi\u003e\u003cmo\u003e)\u003c/mo\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eP(n)=p(i)+P(n-i)\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"strut\" style=\"height:0.75em;\"\u003e\u003c/span\u003e\u003cspan class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"base textstyle uncramped\"\u003e\u003cspan class=\"mord mathit\" style=\"margin-right:0.13889em;\"\u003eP\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003en\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003cspan class=\"mrel\"\u003e=\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003ep\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003ei\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003cspan class=\"mbin\"\u003e+\u003c/span\u003e\u003cspan class=\"mord mathit\" style=\"margin-right:0.13889em;\"\u003eP\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003en\u003c/span\u003e\u003cspan class=\"mbin\"\u003e−\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003ei\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e为最优解， 而\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eP\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmo\u003e−\u003c/mo\u003e\u003cmi\u003ei\u003c/mi\u003e\u003cmo\u003e)\u003c/mo\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eP(n-i)\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"strut\" style=\"height:0.75em;\"\u003e\u003c/span\u003e\u003cspan class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"base textstyle uncramped\"\u003e\u003cspan class=\"mord mathit\" style=\"margin-right:0.13889em;\"\u003eP\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003en\u003c/span\u003e\u003cspan class=\"mbin\"\u003e−\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003ei\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e不是最优解，那么会存在另外一个\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eP\u003c/mi\u003e\u003cmn\u003e1\u003c/mn\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmo\u003e−\u003c/mo\u003e\u003cmi\u003ei\u003c/mi\u003e\u003cmo\u003e)\u003c/mo\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eP1(n-i)\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"strut\" style=\"height:0.75em;\"\u003e\u003c/span\u003e\u003cspan class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"base textstyle uncramped\"\u003e\u003cspan class=\"mord mathit\" style=\"margin-right:0.13889em;\"\u003eP\u003c/span\u003e\u003cspan class=\"mord mathrm\"\u003e1\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003en\u003c/span\u003e\u003cspan class=\"mbin\"\u003e−\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003ei\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e，使得\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eP\u003c/mi\u003e\u003cmn\u003e1\u003c/mn\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmo\u003e)\u003c/mo\u003e\u003cmo\u003e=\u003c/mo\u003e\u003cmi\u003ep\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmi\u003ei\u003c/mi\u003e\u003cmo\u003e)\u003c/mo\u003e\u003cmo\u003e+\u003c/mo\u003e\u003cmi\u003eP\u003c/mi\u003e\u003cmn\u003e1\u003c/mn\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmo\u003e−\u003c/mo\u003e\u003cmi\u003ei\u003c/mi\u003e\u003cmo\u003e)\u003c/mo\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eP1(n)=p(i)+P1(n-i)\n\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"strut\" style=\"height:0.75em;\"\u003e\u003c/span\u003e\u003cspan class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"base textstyle uncramped\"\u003e\u003cspan class=\"mord mathit\" style=\"margin-right:0.13889em;\"\u003eP\u003c/span\u003e\u003cspan class=\"mord mathrm\"\u003e1\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003en\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003cspan class=\"mrel\"\u003e=\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003ep\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003ei\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003cspan class=\"mbin\"\u003e+\u003c/span\u003e\u003cspan class=\"mord mathit\" style=\"margin-right:0.13889em;\"\u003eP\u003c/span\u003e\u003cspan class=\"mord mathrm\"\u003e1\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003en\u003c/span\u003e\u003cspan class=\"mbin\"\u003e−\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003ei\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e为最优解，与\u003cspan class=\"katex\"\u003e\u003cspan class=\"katex-mathml\"\u003e\u003cmath\u003e\u003csemantics\u003e\u003cmrow\u003e\u003cmi\u003eP\u003c/mi\u003e\u003cmo\u003e(\u003c/mo\u003e\u003cmi\u003en\u003c/mi\u003e\u003cmo\u003e)\u003c/mo\u003e\u003c/mrow\u003e\u003cannotation encoding=\"application/x-tex\"\u003eP(n)\u003c/annotation\u003e\u003c/semantics\u003e\u003c/math\u003e\u003c/span\u003e\u003cspan class=\"katex-html\" aria-hidden=\"true\"\u003e\u003cspan class=\"strut\" style=\"height:0.75em;\"\u003e\u003c/span\u003e\u003cspan class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"\u003e\u003c/span\u003e\u003cspan class=\"base textstyle uncramped\"\u003e\u003cspan class=\"mord mathit\" style=\"margin-right:0.13889em;\"\u003eP\u003c/span\u003e\u003cspan class=\"mopen\"\u003e(\u003c/span\u003e\u003cspan class=\"mord mathit\"\u003en\u003c/span\u003e\u003cspan class=\"mclose\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e为最优解矛盾。\u003c/p\u003e\n\u003cp\u003e确定问题的递归式和最优子结构性质后，就可以自底向上递推得出最优解。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eCuttingProblem\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(price []\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e, length \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e {\n\tdp := \u003cspan class=\"hljs-built_in\"\u003emake\u003c/span\u003e([]\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e, length+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n\t\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i := \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; i \u0026lt;= length; i++ {\n\t\t\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e j := \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; j \u0026lt;= i; j++ {\n\t\t\tdp[i] = max(dp[i], price[j]+dp[i-j])\n\t\t}\n\t}\n\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e dp[length]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e另一个问题是\u003cstrong\u003e最优解路径\u003c/strong\u003e。由于具有\u003cstrong\u003e最优子结构\u003c/strong\u003e性质，每个问题的最优解都是由当前问题的解和子问题最优解组成，因此我们\n可以\u003cstrong\u003e从后向前回溯子问题\u003c/strong\u003e，将所有解拼接起来得到最优解路径。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ePath\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(price, cuttingPoint []\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e, length \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003estring\u003c/span\u003e {\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e length \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n\t\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e fmt.Sprintf(\u003cspan class=\"hljs-string\"\u003e\u0026quot;%s+%d[%d]\u0026quot;\u003c/span\u003e, Path(price, cuttingPoint, length-cuttingPoint[length]), cuttingPoint[length], price[cuttingPoint[length]])\n\t}\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026quot;\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eCuttingProblem\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(price []\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e, length \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e {\n\tdp := \u003cspan class=\"hljs-built_in\"\u003emake\u003c/span\u003e([]\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e, length+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n\tcuttingPoint := \u003cspan class=\"hljs-built_in\"\u003emake\u003c/span\u003e([]\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e, length+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n\t\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i := \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; i \u0026lt;= length; i++ {\n\t\t\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e j := \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; j \u0026lt;= i; j++ {\n\t\t\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e price[j]+dp[i-j] \u0026gt; dp[i] {\n\t\t\t\tdp[i] = price[j] + dp[i-j]\n\t\t\t\tcuttingPoint[i] = j\n\t\t\t}\n\t\t}\n\t}\n\n\tfmt.Println(Path(price, cuttingPoint, length))\n\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e dp[length]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://jingyuexing.github.io/Ebook/Algorithm/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA.pdf\"\u003e算法导论\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n","title":"理解动态规划：从切钢管开始","date":"2023-11-13","description":""}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"dp"},"buildId":"uFVsFydzUSYwDaGmMATFd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>