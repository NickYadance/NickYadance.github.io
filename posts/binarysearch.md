---
title: '彻底理解二分搜索的上下界问题'
date: '2023-11-10'
description: '尽管二分查找的基本思想相对简单，但细节可以令人难以招架...'
---
> 尽管二分查找的基本思想相对简单，但细节可以令人难以招架 ... — 高德纳

二分查找的基本思想是通过不断折半缩小查找范围，最终找到目标值。如果只对二分查找的实现死记硬背，在编码过程中非常容易陷入上下界以及终结条件
的选取问题，导致无法写出BugFree的代码。众所周知算法即数学，对于二分搜索，我们用数学的严谨的思想看待它，就不容易出现对细节发晕的问题。

对于一个有序数组 $a[l, r)$ 和目标值 $n$，我们定义一个**循环不变量**为：在**左闭右开的区间[l, r)内，区间左边的元素都比n小(或者不存在)，区间右边的元素都比n大(或者不存在)。**
$$ a[i]<n, i < l $$
$$ a[i]>=n, i >= r $$
我们不断缩小这个区间，直到$l=r$，此时$a[l]$就是目标值n在数组$a[]$中的**下界**，因为l左边的元素都小于n，l右边的元素(包括自身)都大于等于n。
$$ a[i]<n, i < l $$
$$ a[i]>=n, i >= l $$
也就是说，二分搜索中我们要**根据下界可能在的位置不断缩小区间**，直到找到下界。那么二分后会出现两种可能的情况：
1. 如果$n<a[mid]$，下界在mid左边，或者是$a[mid]$，区间$[l, mid)$满足循环不变量
2. 如果$n>=a[mid]$，下界在mid右边，或者是，那么区间$[mid, r)$满足循环不变量
比较难理解的是条件1，
```go
func BinarySearch(arr []int, n int) int {
	low := 0
	high := len(arr)
	for low < high {
		mid := low + (high-low)>>1
		if n < arr[mid] {
			high = mid
		} else if n == arr[mid] {
			return mid
		} else {
			low = mid + 1
		}
	}
	return -1
}
```