<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><meta name="description" content="The blog of a programmer who enjoys learning and building things."/><meta property="og:image" content="https://og-image.vercel.app/WuYi&#x27;s%20Blog.png?theme=light&amp;md=0&amp;fontSize=75px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><meta name="og:title" content="WuYi&#x27;s Blog"/><meta name="twitter:card" content="summary_large_image"/><title>理解k8s资源</title><meta name="next-head-count" content="8"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/f5bbdd045156ccce.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/f5bbdd045156ccce.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/327bdfcd3e98582f.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/327bdfcd3e98582f.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-445a5fe7cadeec28.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-bbecb7d54330d002.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-6e8ee6ae7cc0a14c.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-25345a12794bca3a.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/996-5abd08ae305d436b.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/284-919fb0c78b7b87bc.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-30a9d36a22da8e83.js" defer="" crossorigin=""></script><script src="/_next/static/tBDcWIf9tU2_6gXjzKBx-/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/tBDcWIf9tU2_6gXjzKBx-/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="layout_container__FUycR"><header class="layout_header__SFlEE"></header><main><article><h1 class="utils_headingXl__zlq1q">理解k8s资源</h1><div class="utils_lightText__B_gv3"><time dateTime="2024-01-05">January 5, 2024</time></div><div><h2>request/limit</h2>
<p>request的值有两个作用</p>
<ol>
<li>影响调度策略</li>
<li>影响cpu资源配比</li>
<li>影响oom打分值
`</li>
</ol>
<blockquote>
<p>The scheduler ensures that, for each resource type, the sum of the resource requests of the scheduled containers is less than the capacity of the node. Note that although actual memory or CPU resource usage on nodes is very low, the scheduler still refuses to place a Pod on a node if the capacity check fails.</p>
</blockquote>
<p>request在调度策略中的作用可以总结为：节点上所有容器的request总和不能超过节点容量。这是一个保守的硬性条件，并不会考虑作决策时节点的容器真实资源使用率，这也是实际使用中优化k8s集群资源使用率的一个点，毕竟多数容器会设定一个大的预估值以应对峰值流量。</p>
<p>cpu.request会影响运行时，容器可能分配到的cpu时间片比值，即两个容器的实际cpu资源使用率比值与cpu.request的比值相等。
<img src="/images/understand_the_kubernetes_resource/cpu_request.png" alt="cpu_request"></p>
<p>memory.request并不是在容器一开始就分配到的内存值大小，与cpu.request类似memory.request主要用于调度策略。内存相对于cpu属于不可压缩的“静态资源”，在分配给进程后内存不能动态的伸缩，只能由进程GC或者被操作系统完整回收。memory.request会参与到操作系统oom打分的计算，memory.request使用占比越高的容器越容易被oom。</p>
</div></article></main><div class="layout_backToHome__D9QFr"><a href="/">← Back</a></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"postData":{"id":"understand_the_kubernetes_resource","contentHtml":"\u003ch2\u003erequest/limit\u003c/h2\u003e\n\u003cp\u003erequest的值有两个作用\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e影响调度策略\u003c/li\u003e\n\u003cli\u003e影响cpu资源配比\u003c/li\u003e\n\u003cli\u003e影响oom打分值\n`\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe scheduler ensures that, for each resource type, the sum of the resource requests of the scheduled containers is less than the capacity of the node. Note that although actual memory or CPU resource usage on nodes is very low, the scheduler still refuses to place a Pod on a node if the capacity check fails.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003erequest在调度策略中的作用可以总结为：节点上所有容器的request总和不能超过节点容量。这是一个保守的硬性条件，并不会考虑作决策时节点的容器真实资源使用率，这也是实际使用中优化k8s集群资源使用率的一个点，毕竟多数容器会设定一个大的预估值以应对峰值流量。\u003c/p\u003e\n\u003cp\u003ecpu.request会影响运行时，容器可能分配到的cpu时间片比值，即两个容器的实际cpu资源使用率比值与cpu.request的比值相等。\n\u003cimg src=\"/images/understand_the_kubernetes_resource/cpu_request.png\" alt=\"cpu_request\"\u003e\u003c/p\u003e\n\u003cp\u003ememory.request并不是在容器一开始就分配到的内存值大小，与cpu.request类似memory.request主要用于调度策略。内存相对于cpu属于不可压缩的“静态资源”，在分配给进程后内存不能动态的伸缩，只能由进程GC或者被操作系统完整回收。memory.request会参与到操作系统oom打分的计算，memory.request使用占比越高的容器越容易被oom。\u003c/p\u003e\n","title":"理解k8s资源","date":"2024-01-05","description":"理解k8s资源的相关概念"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"understand_the_kubernetes_resource"},"buildId":"tBDcWIf9tU2_6gXjzKBx-","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>