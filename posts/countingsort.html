<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><meta name="description" content="The blog of a programmer who enjoys learning and building things."/><meta property="og:image" content="https://og-image.vercel.app/WuYi&#x27;s%20Blog.png?theme=light&amp;md=0&amp;fontSize=75px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><meta name="og:title" content="WuYi&#x27;s Blog"/><meta name="twitter:card" content="summary_large_image"/><title>容易被忽略的计数排序稳定性</title><meta name="next-head-count" content="8"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/11f0b3113f1fffe8.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/11f0b3113f1fffe8.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/327bdfcd3e98582f.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/327bdfcd3e98582f.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-445a5fe7cadeec28.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-bbecb7d54330d002.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-6e8ee6ae7cc0a14c.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-25345a12794bca3a.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/640-f96c14577142176a.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-d0d85adcca54aa92.js" defer="" crossorigin=""></script><script src="/_next/static/LKXWr1c9pXyy9a8cV4Fr_/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/LKXWr1c9pXyy9a8cV4Fr_/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="layout_container__FUycR"><header class="layout_header__SFlEE"></header><main><article><h1 class="utils_headingXl__zlq1q">容易被忽略的计数排序稳定性</h1><div class="utils_lightText__B_gv3"><time dateTime="2023-11-14">November 14, 2023</time></div><div><p>计数排序中，一个容易被忽略的点是保持原数组元素的相对顺序，即排序算法的稳定性。在下面的实现中，数组中每个元素被计数后，被进行无序的还原。</p>
<pre><code class="hljs language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CountingSortNaive</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, N <span class="hljs-type">int</span>)</span></span> {
	counting := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, N)
	<span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums {
		counting[num] = counting[num] + <span class="hljs-number">1</span>
	}
	k := <span class="hljs-number">0</span>
	<span class="hljs-keyword">for</span> i, count := <span class="hljs-keyword">range</span> counting {
		<span class="hljs-keyword">for</span> count &gt; <span class="hljs-number">0</span> {
			nums[k] = i
			k = k + <span class="hljs-number">1</span>
			count = count - <span class="hljs-number">1</span>
		}
	}
}
</code></pre>
<p>为了保持稳定性，我们在排序前对计数数组做一个<strong>滚动累加</strong>，以计算出每个值在原数组中对应的下标，最后对原数组从后向前做排序。</p>
<pre><code class="hljs language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CountingSort</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, N <span class="hljs-type">int</span>)</span></span> {
	counting := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, N)
	tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))
	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> nums {
		counting[nums[i]] = counting[nums[i]] + <span class="hljs-number">1</span>
	}
	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> counting {
		counting[i] = counting[i] + counting[i<span class="hljs-number">-1</span>]
	}
	<span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i = i - <span class="hljs-number">1</span> {
		v := nums[i]
		tmp[counting[v]<span class="hljs-number">-1</span>] = v
		counting[v] = counting[v] - <span class="hljs-number">1</span>
	}
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(tmp); i = i + <span class="hljs-number">1</span> {
		nums[i] = tmp[i]
	}
}
</code></pre>
<p>稳定的计数排序能帮助处理基数排序的问题。</p>
<blockquote>
<p><a href="https://jingyuexing.github.io/Ebook/Algorithm/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA.pdf">算法导论</a></p>
</blockquote>
</div></article></main><div class="layout_backToHome__D9QFr"><a href="/">← Back</a></div></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"postData":{"id":"countingsort","contentHtml":"\u003cp\u003e计数排序中，一个容易被忽略的点是保持原数组元素的相对顺序，即排序算法的稳定性。在下面的实现中，数组中每个元素被计数后，被进行无序的还原。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eCountingSortNaive\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(nums []\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e, N \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e {\n\tcounting := \u003cspan class=\"hljs-built_in\"\u003emake\u003c/span\u003e([]\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e, N)\n\t\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e _, num := \u003cspan class=\"hljs-keyword\"\u003erange\u003c/span\u003e nums {\n\t\tcounting[num] = counting[num] + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\t}\n\tk := \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\t\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i, count := \u003cspan class=\"hljs-keyword\"\u003erange\u003c/span\u003e counting {\n\t\t\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e count \u0026gt; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n\t\t\tnums[k] = i\n\t\t\tk = k + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\t\t\tcount = count - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e为了保持稳定性，我们在排序前对计数数组做一个\u003cstrong\u003e滚动累加\u003c/strong\u003e，以计算出每个值在原数组中对应的下标，最后对原数组从后向前做排序。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eCountingSort\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(nums []\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e, N \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e {\n\tcounting := \u003cspan class=\"hljs-built_in\"\u003emake\u003c/span\u003e([]\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e, N)\n\ttmp := \u003cspan class=\"hljs-built_in\"\u003emake\u003c/span\u003e([]\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(nums))\n\t\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i := \u003cspan class=\"hljs-keyword\"\u003erange\u003c/span\u003e nums {\n\t\tcounting[nums[i]] = counting[nums[i]] + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\t}\n\t\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i := \u003cspan class=\"hljs-keyword\"\u003erange\u003c/span\u003e counting {\n\t\tcounting[i] = counting[i] + counting[i\u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e]\n\t}\n\t\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i := \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(nums) - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; i \u0026gt;= \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i = i - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e {\n\t\tv := nums[i]\n\t\ttmp[counting[v]\u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e] = v\n\t\tcounting[v] = counting[v] - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\t}\n\t\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i := \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(tmp); i = i + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e {\n\t\tnums[i] = tmp[i]\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e稳定的计数排序能帮助处理基数排序的问题。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://jingyuexing.github.io/Ebook/Algorithm/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA.pdf\"\u003e算法导论\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n","title":"容易被忽略的计数排序稳定性","date":"2023-11-14","description":"尽管二分查找的基本思想相对简单，但细节可以令人难以招架..."}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"countingsort"},"buildId":"LKXWr1c9pXyy9a8cV4Fr_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>