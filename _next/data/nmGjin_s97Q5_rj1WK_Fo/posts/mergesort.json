{"pageProps":{"postData":{"id":"mergesort","contentHtml":"<blockquote>\n<p>如果说没有分治，那么计算机在任何方面都不比人类高效 - 我说的</p>\n</blockquote>\n<p>分治算法的思路是将原问题，拆分成若干个更小规模的子问题，并将子问题的解进行合并得到原问题的解。归并排序是使用分治算法解决的经典问题之一。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-function\"><span class=\"hljs-title\">DivideAndConquer</span><span class=\"hljs-params\">(N)</span></span>:\n\t<span class=\"hljs-keyword\">if</span> N eligible:\n\t\tr1 := <span class=\"hljs-built_in\">DivideAndConquer</span>(<span class=\"hljs-built_in\">sub</span>(N))\n\t\tr2 := <span class=\"hljs-built_in\">DivideAndConquer</span>(<span class=\"hljs-built_in\">sub</span>(N))\n\t\treturn <span class=\"hljs-built_in\">conquer</span>(r1,r2) \n</code></pre>\n<p>归并排序的流程完全对照分治算法的实现：</p>\n<ol>\n<li>将数组分成两半</li>\n<li>分别两个子数组进行排序</li>\n<li>将两个已排序的子数组合并</li>\n</ol>\n<p>直接上代码。</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Merge</span><span class=\"hljs-params\">(nums, tmp []<span class=\"hljs-type\">int</span>, l, mid, r <span class=\"hljs-type\">int</span>)</span></span> {\n\tk := l\n\tl1 := l\n\tr1 := mid\n\tl2 := mid + <span class=\"hljs-number\">1</span>\n\tr2 := r\n\t<span class=\"hljs-keyword\">for</span> l1 &lt;= r1 &amp;&amp; l2 &lt;= r2 {\n\t\t<span class=\"hljs-keyword\">if</span> nums[l1] &lt; nums[l2] {\n\t\t\ttmp[k] = nums[l1]\n\t\t\tl1 = l1 + <span class=\"hljs-number\">1</span>\n\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\ttmp[k] = nums[l2]\n\t\t\tl2 = l2 + <span class=\"hljs-number\">1</span>\n\t\t}\n\t\tk = k + <span class=\"hljs-number\">1</span>\n\t}\n\t<span class=\"hljs-keyword\">for</span> l1 &lt;= r1 {\n\t\ttmp[k] = nums[l1]\n\t\tl1 = l1 + <span class=\"hljs-number\">1</span>\n\t\tk = k + <span class=\"hljs-number\">1</span>\n\t}\n\t<span class=\"hljs-keyword\">for</span> l2 &lt;= r2 {\n\t\ttmp[k] = nums[l2]\n\t\tl2 = l2 + <span class=\"hljs-number\">1</span>\n\t\tk = k + <span class=\"hljs-number\">1</span>\n\t}\n\t<span class=\"hljs-keyword\">for</span> l &lt;= r {\n\t\tnums[l] = tmp[l]\n\t\tl = l + <span class=\"hljs-number\">1</span>\n\t}\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">MergeSort</span><span class=\"hljs-params\">(nums, tmp []<span class=\"hljs-type\">int</span>, l, r <span class=\"hljs-type\">int</span>)</span></span> {\n\t<span class=\"hljs-keyword\">if</span> r &gt; l {\n\t\tmid := l + (r-l)&gt;&gt;<span class=\"hljs-number\">1</span>\n\t\tMergeSort(nums, tmp, l, mid)\n\t\tMergeSort(nums, tmp, mid+<span class=\"hljs-number\">1</span>, r)\n\t\tMerge(nums, tmp, l, mid, r)\n\t}\n}\n</code></pre>\n<p>归并排序具有典型的递归子问题结构，且每次产生两个同等规模（<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">N</span></span></span></span>为奇数时不完全相同）的子问题，其时间复杂度的递归式如下。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>T</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mrow><mo fence=\"true\">{</mo><mtable><mtr><mtd><mrow><mi>c</mi></mrow></mtd><mtd><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd></mtr><mtr><mtd><mrow><mn>2</mn><mi>T</mi><mo>(</mo><mi>n</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo>)</mo><mo>+</mo><mi>c</mi><mi>n</mi></mrow></mtd><mtd><mrow><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding=\"application/x-tex\">T(n)=\n\\begin{cases}\nc &amp;n=1 \\\\\\\\\n2T(n/2)+cn &amp;n&gt;1\n\\end{cases}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:2.41em;\"></span><span class=\"strut bottom\" style=\"height:4.32em;vertical-align:-1.9100000000000001em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"minner displaystyle textstyle uncramped\"><span class=\"style-wrap reset-textstyle textstyle uncramped\"><span class=\"delimsizing mult\"><span class=\"vlist\"><span style=\"top:0.9500099999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎩</span></span></span><span style=\"top:0.9500099999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎪</span></span></span><span style=\"top:-0.000010000000000287557em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎨</span></span></span><span style=\"top:-1.1500100000000002em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎪</span></span></span><span style=\"top:-1.4500200000000003em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"delimsizinginner delim-size4\"><span>⎧</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-l\"><span class=\"vlist\"><span style=\"top:-1.4020000000000001em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathit\">c</span></span></span><span style=\"top:0.0379999999999997em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"></span></span><span style=\"top:1.4779999999999998em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathrm\">2</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mord mathrm\">/</span><span class=\"mord mathrm\">2</span><span class=\"mclose\">)</span><span class=\"mbin\">+</span><span class=\"mord mathit\">c</span><span class=\"mord mathit\">n</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span><span class=\"arraycolsep\" style=\"width:1em;\"></span><span class=\"col-align-l\"><span class=\"vlist\"><span style=\"top:-1.4020000000000001em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathit\">n</span><span class=\"mrel\">=</span><span class=\"mord mathrm\">1</span></span></span><span style=\"top:1.4780000000000002em;\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span><span class=\"mord displaystyle textstyle uncramped\"><span class=\"mord mathit\">n</span><span class=\"mrel\">&gt;</span><span class=\"mord mathrm\">1</span></span></span><span class=\"baseline-fix\"><span class=\"fontsize-ensurer reset-size5 size5\"><span style=\"font-size:0em;\">​</span></span>​</span></span></span></span></span><span class=\"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter\"></span></span></span></span></span></span></p>\n<p>大部分分治算法都有类似结构的递归式，递归式生成的<strong>递归树</strong>如图。树的总高度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo>+</mo><mi>l</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1 + lgn</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathrm\">1</span><span class=\"mbin\">+</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathit\">n</span></span></span></span>，每层的复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>c</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">cn</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">c</span><span class=\"mord mathit\">n</span></span></span></span>，总代价为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mi>l</mi><mi>g</mi><mi>n</mi><mo>)</mo><mi>c</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">(1+lgn)cn</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mopen\">(</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">+</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathit\">n</span><span class=\"mclose\">)</span><span class=\"mord mathit\">c</span><span class=\"mord mathit\">n</span></span></span></span>，即<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mi>O</mi><mo>(</mo><mi>l</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">nO(lgn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathit\">n</span><span class=\"mclose\">)</span></span></span></span>。\n<img src=\"/images/recursive_tree.png\" alt=\"递推树\"></p>\n<blockquote>\n<p><a href=\"https://jingyuexing.github.io/Ebook/Algorithm/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA.pdf\">算法导论</a></p>\n</blockquote>\n","title":"分治算法的时间复杂度","date":"2023-11-13","description":""}},"__N_SSG":true}