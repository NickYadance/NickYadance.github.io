{"pageProps":{"postData":{"id":"countingsort","contentHtml":"<p>计数排序中，一个容易被忽略的点是保持原数组元素的相对顺序，即排序算法的稳定性。在下面的实现中，数组中每个元素被计数后，被进行无序的还原。</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">CountingSortNaive</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, N <span class=\"hljs-type\">int</span>)</span></span> {\n\tcounting := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, N)\n\t<span class=\"hljs-keyword\">for</span> _, num := <span class=\"hljs-keyword\">range</span> nums {\n\t\tcounting[num] = counting[num] + <span class=\"hljs-number\">1</span>\n\t}\n\tk := <span class=\"hljs-number\">0</span>\n\t<span class=\"hljs-keyword\">for</span> i, count := <span class=\"hljs-keyword\">range</span> counting {\n\t\t<span class=\"hljs-keyword\">for</span> count &gt; <span class=\"hljs-number\">0</span> {\n\t\t\tnums[k] = i\n\t\t\tk = k + <span class=\"hljs-number\">1</span>\n\t\t\tcount = count - <span class=\"hljs-number\">1</span>\n\t\t}\n\t}\n}\n</code></pre>\n<p>为了保持稳定性，我们在排序前对计数数组做一个<strong>滚动累加</strong>，以计算出每个值在原数组中对应的下标，最后对原数组从后向前做排序。</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">CountingSort</span><span class=\"hljs-params\">(nums []<span class=\"hljs-type\">int</span>, N <span class=\"hljs-type\">int</span>)</span></span> {\n\tcounting := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, N)\n\ttmp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-built_in\">len</span>(nums))\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">range</span> nums {\n\t\tcounting[nums[i]] = counting[nums[i]] + <span class=\"hljs-number\">1</span>\n\t}\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">range</span> counting {\n\t\tcounting[i] = counting[i] + counting[i<span class=\"hljs-number\">-1</span>]\n\t}\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-built_in\">len</span>(nums) - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i = i - <span class=\"hljs-number\">1</span> {\n\t\tv := nums[i]\n\t\ttmp[counting[v]<span class=\"hljs-number\">-1</span>] = v\n\t\tcounting[v] = counting[v] - <span class=\"hljs-number\">1</span>\n\t}\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(tmp); i = i + <span class=\"hljs-number\">1</span> {\n\t\tnums[i] = tmp[i]\n\t}\n}\n</code></pre>\n<p>稳定的计数排序能帮助处理基数排序的问题。</p>\n<blockquote>\n<p><a href=\"https://jingyuexing.github.io/Ebook/Algorithm/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA.pdf\">算法导论</a></p>\n</blockquote>\n","title":"容易被忽略的计数排序稳定性","date":"2023-11-14","description":"尽管二分查找的基本思想相对简单，但细节可以令人难以招架..."}},"__N_SSG":true}