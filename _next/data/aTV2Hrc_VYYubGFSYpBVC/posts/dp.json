{"pageProps":{"postData":{"id":"dp","contentHtml":"<p>动态规划(dynamic programming)是一种分治算法，可以解决一类拥有特定性质的问题，针对这些问题，动态规划提供一种高效的解决思路。特定性质包括两点：</p>\n<ol>\n<li>重复子问题</li>\n<li>最优子结构</li>\n</ol>\n<p>两种性质按字面意义理解都不难，1，有被重复处理的子问题；2，当父问题的解是最优时，子问题也是最优，具体问题中的难点是发现问题具有这两种性质，并做出子问题的定义。\n本文以切钢管问题为例子，介绍动态规划的问题解决原理和编码模板。</p>\n<p>钢管问题：已知长度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.65952em;\"></span><span class=\"strut bottom\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">i</span></span></span></span>的钢管的的售价为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">p(i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">p</span><span class=\"mopen\">(</span><span class=\"mord mathit\">i</span><span class=\"mclose\">)</span></span></span></span>，现在可将长度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span></span></span></span>的钢管切成任意段，求所有片段的售价总和最大值。</p>\n<p>直观的看，对于长度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span></span></span></span>的钢管，我们可以分别尝试在长度<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo separator=\"true\">,</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">1,2,...,n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.64444em;\"></span><span class=\"strut bottom\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathrm\">1</span><span class=\"mpunct\">,</span><span class=\"mord mathrm\">2</span><span class=\"mpunct\">,</span><span class=\"mord mathrm\">.</span><span class=\"mord mathrm\">.</span><span class=\"mord mathrm\">.</span><span class=\"mpunct\">,</span><span class=\"mord mathit\">n</span></span></span></span>的位置“砍一刀”得到一个切分方案，得到一个递归式。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>M</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>p</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>+</mo><mi>P</mi><mo>(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>)</mo><mo>)</mo><mo separator=\"true\">,</mo><mi>i</mi><mo>∈</mo><mo>[</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">P(n)=Max(p(i) + P(n-i)), i \\in [1,n]\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathit\">a</span><span class=\"mord mathit\">x</span><span class=\"mopen\">(</span><span class=\"mord mathit\">p</span><span class=\"mopen\">(</span><span class=\"mord mathit\">i</span><span class=\"mclose\">)</span><span class=\"mbin\">+</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathit\">i</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mord mathit\">i</span><span class=\"mrel\">∈</span><span class=\"mopen\">[</span><span class=\"mord mathrm\">1</span><span class=\"mpunct\">,</span><span class=\"mord mathit\">n</span><span class=\"mclose\">]</span></span></span></span></span></p>\n<p>画出<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><mo>(</mo><mn>4</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">P(4)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">4</span><span class=\"mclose\">)</span></span></span></span>的递归树，树中有多个重复的子节点<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo separator=\"true\">,</mo><mi>P</mi><mo>(</mo><mn>2</mn><mo>)</mo><mo separator=\"true\">,</mo><mi>P</mi><mo>(</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">P(1),P(2),P(0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">2</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">0</span><span class=\"mclose\">)</span></span></span></span>，说明问题满足动态规划的性质之一：<strong>重复子问题</strong>。</p>\n<p><img src=\"/images/dp_cutting_recursive_tree.png\" alt=\"dp_cutting_recursive_tree.png\"></p>\n<p>切钢管问题中，每次切分后只会产生一个不重叠的子问题，可以通过<strong>cut-paste</strong>方法进行反证最优子结构。对于一般\n的动态规划问题，也可以通过这种方式进行证明。</p>\n<p>假设<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>p</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>+</mo><mi>P</mi><mo>(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">P(n)=p(i)+P(n-i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\">p</span><span class=\"mopen\">(</span><span class=\"mord mathit\">i</span><span class=\"mclose\">)</span><span class=\"mbin\">+</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathit\">i</span><span class=\"mclose\">)</span></span></span></span>为最优解， 而<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">P(n-i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathit\">i</span><span class=\"mclose\">)</span></span></span></span>不是最优解，那么会存在另外一个<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><mn>1</mn><mo>(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">P1(n-i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathrm\">1</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathit\">i</span><span class=\"mclose\">)</span></span></span></span>，使得<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><mn>1</mn><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>p</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>+</mo><mi>P</mi><mn>1</mn><mo>(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">P1(n)=p(i)+P1(n-i)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathrm\">1</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\">p</span><span class=\"mopen\">(</span><span class=\"mord mathit\">i</span><span class=\"mclose\">)</span><span class=\"mbin\">+</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathrm\">1</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mbin\">−</span><span class=\"mord mathit\">i</span><span class=\"mclose\">)</span></span></span></span>为最优解，与<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">P(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mclose\">)</span></span></span></span>为最优解矛盾。</p>\n<p>确定问题的递归式和最优子结构性质后，就可以自底向上递推得出最优解。</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">CuttingProblem</span><span class=\"hljs-params\">(price []<span class=\"hljs-type\">int</span>, length <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> {\n\tdp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, length+<span class=\"hljs-number\">1</span>)\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt;= length; i++ {\n\t\t<span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">1</span>; j &lt;= i; j++ {\n\t\t\tdp[i] = max(dp[i], price[j]+dp[i-j])\n\t\t}\n\t}\n\n\t<span class=\"hljs-keyword\">return</span> dp[length]\n}\n</code></pre>\n<p>另一个问题是<strong>最优解路径</strong>。由于具有<strong>最优子结构</strong>性质，每个问题的最优解都是由当前问题的解和子问题最优解组成，因此我们\n可以<strong>从后向前回溯子问题</strong>，将所有解拼接起来得到最优解路径。</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Path</span><span class=\"hljs-params\">(price, cuttingPoint []<span class=\"hljs-type\">int</span>, length <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">string</span> {\n\t<span class=\"hljs-keyword\">if</span> length &gt; <span class=\"hljs-number\">0</span> {\n\t\t<span class=\"hljs-keyword\">return</span> fmt.Sprintf(<span class=\"hljs-string\">&quot;%s+%d[%d]&quot;</span>, Path(price, cuttingPoint, length-cuttingPoint[length]), cuttingPoint[length], price[cuttingPoint[length]])\n\t}\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">CuttingProblem</span><span class=\"hljs-params\">(price []<span class=\"hljs-type\">int</span>, length <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> {\n\tdp := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, length+<span class=\"hljs-number\">1</span>)\n\tcuttingPoint := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, length+<span class=\"hljs-number\">1</span>)\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">1</span>; i &lt;= length; i++ {\n\t\t<span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">1</span>; j &lt;= i; j++ {\n\t\t\t<span class=\"hljs-keyword\">if</span> price[j]+dp[i-j] &gt; dp[i] {\n\t\t\t\tdp[i] = price[j] + dp[i-j]\n\t\t\t\tcuttingPoint[i] = j\n\t\t\t}\n\t\t}\n\t}\n\n\tfmt.Println(Path(price, cuttingPoint, length))\n\n\t<span class=\"hljs-keyword\">return</span> dp[length]\n}\n</code></pre>\n<blockquote>\n<p><a href=\"https://jingyuexing.github.io/Ebook/Algorithm/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA.pdf\">算法导论</a></p>\n</blockquote>\n","title":"理解动态规划：从切钢管开始","date":"2023-11-13","description":""}},"__N_SSG":true}