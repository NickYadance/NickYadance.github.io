{"pageProps":{"postData":{"id":"mysql_distributed_lock","contentHtml":"<p>最近在一份代码中看到基于Mysql的分布式锁实现，首先有一张锁表(脱敏)：</p>\n<pre><code class=\"hljs language-mysql\">CREATE TABLE `lock_tab`\n(\n    `id`         bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n    `lock_type`  int                 NOT NULL,\n    `lock_owner` varchar(127)        NOT NULL,\n    `lock_ts`    datetime            NOT NULL,\n    `reserved`   text default NULL,\n    PRIMARY KEY (`id`),\n    UNIQUE KEY `uniq_idx_lock_type` (`lock_type`)\n)\n</code></pre>\n<p>加锁流程的伪代码</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-comment\">// distributed lock with Mysql</span>\nhostIp := <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.1</span>\nlockType := <span class=\"hljs-number\">1</span>\nlock := db.model(<span class=\"hljs-string\">&quot;lock_tab&quot;</span>).where(<span class=\"hljs-string\">&quot;lock_type = ?&quot;</span>, some_lock_type)\n<span class=\"hljs-keyword\">if</span> !lock {\n\tdb.model(<span class=\"hljs-string\">&quot;lock_tab&quot;</span>).insert(&amp;Lock{LockType: lockType, LockOwner: hostIP, LockTs: time.Now()})\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n}\n\n<span class=\"hljs-comment\">// the lock belongs to someone else and not expired yet</span>\n<span class=\"hljs-keyword\">if</span> lock.LockOwner != hostIp &amp;&amp; notExpire(lock.Ts) {\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n}\n\n<span class=\"hljs-comment\">// lock acquired, refresh the lease</span>\ndb.model(<span class=\"hljs-string\">&quot;lock_tab&quot;</span>).update(&amp;Lock{LockType: lockType, LockOwner: hostIP, LockTs: time.Now()})\n<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n</code></pre>\n<p>这份分布式锁的实现有几个特点：</p>\n<ol>\n<li>以进程所在机器(容器)的ip作为标识，因此每台机器最多一个实例获取到锁</li>\n<li>带过期时间</li>\n<li>无锁，没有施加行锁</li>\n</ol>\n<p>这份代码的本意是限制crontab任务在多实例上的运行，因此才有lockType对应不同的cronTab任务。那么这份代码有没有问题，能不能正常工作呢？</p>\n<p>我的答案是<strong>有很大问题，但大概率能正常工作</strong>。问题在于当锁过期时，有很高的风险会出现多个实例获取到锁并错误的对锁做续期，又由于实例都是以crontab周期获取锁，当实例数超过一定值问题出现的频率会非常高。但这份代码的运行场景恰好只有2个实例，因此大概率是能正常工作。同时，这份代码还存在一些时间戳同步、ip重用的细节问题。</p>\n<p>这份代码也引起我对一个常见问题的思考：到底如何基于Mysql实现一份可用、高效的分布式锁呢？</p>\n<p>在Redis中，实现一个分布式锁是简单而直观的：</p>\n<pre><code class=\"hljs\"><span class=\"hljs-comment\">// 加锁</span>\nSET my_lock my_random_value NX PX <span class=\"hljs-number\">30000</span>\n\n<span class=\"hljs-comment\">// 解锁</span>\nEVAL <span class=\"hljs-string\">&quot;if redis.call(&#x27;</span>get&#x27;, KEYS[<span class=\"hljs-number\">1</span>]) == ARGV[<span class=\"hljs-number\">1</span>] <span class=\"hljs-keyword\">then</span> <span class=\"hljs-keyword\">return</span> redis.call(<span class=\"hljs-string\">&#x27;del&#x27;</span>, KEYS[<span class=\"hljs-number\">1</span>]) <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">end</span><span class=\"hljs-string\">&quot; 1 my_lock my_random_value\n</span></code></pre>\n<p>以Redis为标杆，我对Mysql分布式锁的实现思路有：</p>\n<ol>\n<li>server side，规避本地计算可能出现的时间戳问题</li>\n<li>原子性</li>\n<li>无锁</li>\n</ol>\n<p>在一番搜索和对比后chatgpt4给出的解是最符合要求的，同时兼容Mysql5.0/8.0。实际运用中，程序可以生成一个随机值作为<code>lock_name</code>，判断加锁语句返回的affectedRows来判定是否加锁成功。</p>\n<pre><code class=\"hljs language-mysql\">CREATE TABLE `distributed_lock` (\n  `lock_name` VARCHAR(255) NOT NULL,\n  `lock_timestamp` BIGINT UNSIGNED NOT NULL,\n  `lock_ttl` INT UNSIGNED NOT NULL,\n  PRIMARY KEY (`lock_name`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n# 加锁\nINSERT INTO `distributed_lock` (`lock_name`, `lock_timestamp`, `lock_ttl`)\nVALUES ('my_lock', UNIX_TIMESTAMP(), 10)\nON DUPLICATE KEY UPDATE\n                     `lock_timestamp` = IF(UNIX_TIMESTAMP() - `lock_timestamp` &gt; `lock_ttl`, VALUES(`lock_timestamp`), `lock_timestamp`),\n                     `lock_ttl` = IF(UNIX_TIMESTAMP() - `lock_timestamp` &gt; `lock_ttl`, VALUES(`lock_ttl`), `lock_ttl`);\n\n# 解锁\nDELETE FROM `distributed_lock` WHERE `lock_name` = 'my_lock';\n</code></pre>\n","title":"Mysql分布式锁","date":"2024-01-11","description":"尽管分布式锁有很多成熟的实现方案，Mysql却常常是小应用场景下的第一存储选择"}},"__N_SSG":true}