{"pageProps":{"postData":{"id":"binarysearch","contentHtml":"<blockquote>\n<p>尽管二分查找的基本思想相对简单，但细节可以令人难以招架 — 高德纳</p>\n</blockquote>\n<p>二分查找是一个迭代算法，基本思想是通过不断折半缩小查找范围，最终找到目标值。</p>\n<p>如果只对二分查找的代码实现死记硬背，在编码过程中容易对上下界和终结条件发晕导致无法写出BugFree的代码。我们用数学的思想循环不变量来描述迭代过程，避免发晕。循环不变量的原理类似多米诺骨牌，包括四个要素</p>\n<ol>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">Variant</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathit\">a</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">a</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\">t</span></span></span></span>: 定义</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">Start</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathit\">t</span><span class=\"mord mathit\">a</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathit\">t</span></span></span></span>: 初始化</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>L</mi><mi>o</mi><mi>o</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">Loop</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">L</span><span class=\"mord mathit\">o</span><span class=\"mord mathit\">o</span><span class=\"mord mathit\">p</span></span></span></span>: 保持</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>E</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">End</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\">d</span></span></span></span>: 终止</li>\n</ol>\n<p>首先我们定义二分查找的循环不变量为: 对于有序数组<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>l</mi><mo separator=\"true\">,</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">a[l,r)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">a</span><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span></span></span></span>和目标值<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span></span></span></span>，在<strong>数组区间<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator=\"true\">,</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">[l, r)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span></span></span></span>内，区间左边的元素小于<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span></span></span></span>，区间右边的元素大于等于<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span></span></span></span>，即</strong></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>&lt;</mo><mi>n</mi><mtext> </mtext><mi>i</mi><mi>f</mi><mtext> </mtext><mi>i</mi><mo>&lt;</mo><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">a[i]&lt;n \\ if \\ i &lt; l \n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\">a</span><span class=\"mopen\">[</span><span class=\"mord mathit\">i</span><span class=\"mclose\">]</span><span class=\"mrel\">&lt;</span><span class=\"mord mathit\">n</span><span class=\"mord mspace\"> </span><span class=\"mord mathit\">i</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mspace\"> </span><span class=\"mord mathit\">i</span><span class=\"mrel\">&lt;</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>&gt;</mo><mo>=</mo><mi>n</mi><mtext> </mtext><mi>i</mi><mi>f</mi><mtext> </mtext><mi>i</mi><mo>&gt;</mo><mo>=</mo><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">a[i]&gt;=n \\ if \\ i &gt;= r \n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base displaystyle textstyle uncramped\"><span class=\"mord mathit\">a</span><span class=\"mopen\">[</span><span class=\"mord mathit\">i</span><span class=\"mclose\">]</span><span class=\"mrel\">&gt;</span><span class=\"mrel\">=</span><span class=\"mord mathit\">n</span><span class=\"mord mspace\"> </span><span class=\"mord mathit\">i</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mspace\"> </span><span class=\"mord mathit\">i</span><span class=\"mrel\">&gt;</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span></span></span></span></span></p>\n<p>算法开始时有<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>l</mi><mo>=</mo><mn>0</mn><mo separator=\"true\">,</mo><mi>r</mi><mo>=</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">l=0,r=len(a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mrel\">=</span><span class=\"mord mathrm\">0</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">e</span><span class=\"mord mathit\">n</span><span class=\"mopen\">(</span><span class=\"mord mathit\">a</span><span class=\"mclose\">)</span></span></span></span>，循环不变量成立。</p>\n<p>不断缩小这个区间直到<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>l</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">l=r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span></span></span></span>，此时<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">l</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span></span></span></span>左边的元素都小于<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">l</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span></span></span></span>右边的元素(包括自身)都大于等于<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span></span></span></span>，我们得到一个有用的数学性质，即<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>l</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">a[l]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">a</span><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mclose\">]</span></span></span></span>是目标值n在数组<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">a</span></span></span></span>中的<strong>下界</strong>，循环不变量定义的区间就是<strong>目标值下界所在的区间</strong>。</p>\n<blockquote>\n<p>数组中N的下界是第一个大于或等于N的元素下标</p>\n</blockquote>\n<p>保持过程就是要寻找下一个下界所在的子区间。</p>\n<ol>\n<li>如果<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mi>a</mi><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">n &gt; a[mid]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span><span class=\"mrel\">&gt;</span><span class=\"mord mathit\">a</span><span class=\"mopen\">[</span><span class=\"mord mathit\">m</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">d</span><span class=\"mclose\">]</span></span></span></span>，n的下界在mid右边且不包括mid，区间<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">[mid + 1, r)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mopen\">[</span><span class=\"mord mathit\">m</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">d</span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span></span></span></span>满足循环不变量</li>\n<li>如果<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>&lt;</mo><mo>=</mo><mi>a</mi><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">n &lt;= a[mid]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span><span class=\"mrel\">&lt;</span><span class=\"mrel\">=</span><span class=\"mord mathit\">a</span><span class=\"mopen\">[</span><span class=\"mord mathit\">m</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">d</span><span class=\"mclose\">]</span></span></span></span>，n的下界在mid左边且包括mid，区间<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator=\"true\">,</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">[l, mid)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mpunct\">,</span><span class=\"mord mathit\">m</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">d</span><span class=\"mclose\">)</span></span></span></span>满足循环不变量</li>\n</ol>\n<p>对照四要素，就可以写出<strong>寻找目标值下界</strong>的二分搜索算法。</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">BinarySearchLowerBound</span><span class=\"hljs-params\">(arr []<span class=\"hljs-type\">int</span>, n <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> {\n\tlow := <span class=\"hljs-number\">0</span>\n\thigh := <span class=\"hljs-built_in\">len</span>(arr)\n\t<span class=\"hljs-keyword\">for</span> low &lt; high {\n\t\tmid := low + (high-low)&gt;&gt;<span class=\"hljs-number\">1</span>\n\t\t<span class=\"hljs-keyword\">if</span> n &gt; arr[mid] {\n\t\t\tlow = mid + <span class=\"hljs-number\">1</span>\n\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\thigh = mid\n\t\t}\n\t}\n\t<span class=\"hljs-keyword\">return</span> low\n}\n</code></pre>\n<p>二分查找可以在二分搜索下界的基础上实现，在迭代过程中提前判断<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>]</mo><mo>=</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">a[mid]=n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">a</span><span class=\"mopen\">[</span><span class=\"mord mathit\">m</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">d</span><span class=\"mclose\">]</span><span class=\"mrel\">=</span><span class=\"mord mathit\">n</span></span></span></span>可以减少迭代次数，但丢失掉了下界算法的<strong>稳定性</strong>，因为下界只会有一个值。</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">BinarySearch</span><span class=\"hljs-params\">(arr []<span class=\"hljs-type\">int</span>, n <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> {\n\tlowerBound := BinarySearchLowerBound(arr, n)\n\t<span class=\"hljs-keyword\">if</span> lowerBound &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; lowerBound &lt; <span class=\"hljs-built_in\">len</span>(arr) &amp;&amp; arr[lowerBound] == n {\n\t\t<span class=\"hljs-keyword\">return</span> lowerBound\n\t}\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>\n}\n</code></pre>\n<p>与下界相对应的上界怎么求呢？数学定义里上下界对应的是一个数在排序数组的两端，例如下面例子里3的下界是a[2]，上界是a[4]。但是套用我们的下界算法并不能得到上界为4(你可以试试)，这时候可以做个处理，定义上界为<strong>数学上界的右一位</strong>，即例子里的a[5]。</p>\n<pre><code class=\"hljs\"><span class=\"hljs-attribute\">a</span>[i] <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span>(lower) <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">3</span>(upper) <span class=\"hljs-number\">4</span>(upper&#x27;)\n<span class=\"hljs-attribute\">i</span>    <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span>        <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span>        <span class=\"hljs-number\">5</span>\n</code></pre>\n<p>这种处理方式参考的是c++ std里<a href=\"https://en.cppreference.com/w/cpp/algorithm/upper_bound\">upper_bound</a>&amp;<a href=\"https://en.cppreference.com/w/cpp/algorithm/lower_bound\">lower_bound</a>的定义，上下界分别是在数组中<strong>插入目标值并保持有序的第一个和最后一个位置</strong>。</p>\n<ul>\n<li>lower_bound: Searches for the first element in the partitioned range [first, last) which is <strong>not ordered before</strong> value.</li>\n<li>upper_bound: Searches for the first element in the partitioned range [first, last) which is <strong>ordered after</strong> value.</li>\n</ul>\n<p>循环不变量只需要修改保持过程，将<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mi>a</mi><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">n&gt;a[mid]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span><span class=\"mrel\">&gt;</span><span class=\"mord mathit\">a</span><span class=\"mopen\">[</span><span class=\"mord mathit\">m</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">d</span><span class=\"mclose\">]</span></span></span></span>修改为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mo>=</mo><mi>a</mi><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">n&gt;=a[mid]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span><span class=\"mrel\">&gt;</span><span class=\"mrel\">=</span><span class=\"mord mathit\">a</span><span class=\"mopen\">[</span><span class=\"mord mathit\">m</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">d</span><span class=\"mclose\">]</span></span></span></span></p>\n<ol>\n<li>如果<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mo>=</mo><mi>a</mi><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">n &gt;= a[mid]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span><span class=\"mrel\">&gt;</span><span class=\"mrel\">=</span><span class=\"mord mathit\">a</span><span class=\"mopen\">[</span><span class=\"mord mathit\">m</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">d</span><span class=\"mclose\">]</span></span></span></span>，n的上界在mid右边且不包括mid，区间<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">[mid + 1, r)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mopen\">[</span><span class=\"mord mathit\">m</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">d</span><span class=\"mbin\">+</span><span class=\"mord mathrm\">1</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span></span></span></span>满足循环不变量</li>\n<li>如果<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>&lt;</mo><mi>a</mi><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">n &lt; a[mid]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span><span class=\"mrel\">&lt;</span><span class=\"mord mathit\">a</span><span class=\"mopen\">[</span><span class=\"mord mathit\">m</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">d</span><span class=\"mclose\">]</span></span></span></span>，n的上界在mid左边且包括mid，区间<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator=\"true\">,</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">[l, mid)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mpunct\">,</span><span class=\"mord mathit\">m</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">d</span><span class=\"mclose\">)</span></span></span></span>满足循环不变量</li>\n</ol>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">BinarySearchUpperBound</span><span class=\"hljs-params\">(arr []<span class=\"hljs-type\">int</span>, n <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> {\n\tlow := <span class=\"hljs-number\">0</span>\n\thigh := <span class=\"hljs-built_in\">len</span>(arr)\n\t<span class=\"hljs-keyword\">for</span> low &lt; high {\n\t\tmid := low + (high-low)&gt;&gt;<span class=\"hljs-number\">1</span>\n\t\t<span class=\"hljs-keyword\">if</span> n &gt;= arr[mid] {\n\t\t\tlow = mid + <span class=\"hljs-number\">1</span>\n\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\thigh = mid\n\t\t}\n\t}\n\t<span class=\"hljs-keyword\">return</span> low\n}\n</code></pre>\n<p>另外在以上的定义下，N的上界与N+1的下界位置相同，可以直接用下界换算。</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">BinarySearchUpperBound</span><span class=\"hljs-params\">(arr []<span class=\"hljs-type\">int</span>, n <span class=\"hljs-type\">int</span>)</span></span> <span class=\"hljs-type\">int</span> {\n\t<span class=\"hljs-keyword\">return</span> BinarySearchLowerBound(arr, n + <span class=\"hljs-number\">1</span>)\n}\n</code></pre>\n<p>总结一下二分查找的循环不变量四要素，对有序数组<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>l</mi><mo separator=\"true\">,</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">a[l,r)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">a</span><span class=\"mopen\">[</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span></span></span></span></p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">Variant</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathit\">a</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">a</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\">t</span></span></span></span>: 目标值下界所在的区间</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">Start</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathit\">t</span><span class=\"mord mathit\">a</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathit\">t</span></span></span></span>: <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>l</mi><mo>=</mo><mn>0</mn><mo separator=\"true\">,</mo><mi>r</mi><mo>=</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>(</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">l=0,r=len(a)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mrel\">=</span><span class=\"mord mathrm\">0</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathit\">e</span><span class=\"mord mathit\">n</span><span class=\"mopen\">(</span><span class=\"mord mathit\">a</span><span class=\"mclose\">)</span></span></span></span></li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>L</mi><mi>o</mi><mi>o</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">Loop</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">L</span><span class=\"mord mathit\">o</span><span class=\"mord mathit\">o</span><span class=\"mord mathit\">p</span></span></span></span>: 如果<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mi>a</mi><mo>[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">n&gt;a[mid]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\">n</span><span class=\"mrel\">&gt;</span><span class=\"mord mathit\">a</span><span class=\"mopen\">[</span><span class=\"mord mathit\">m</span><span class=\"mord mathit\">i</span><span class=\"mord mathit\">d</span><span class=\"mclose\">]</span></span></span></span>，则n的下界在mid右边且不包括mid，反之在左边</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>E</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">End</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathit\">n</span><span class=\"mord mathit\">d</span></span></span></span>: <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>l</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">l=r</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base textstyle uncramped\"><span class=\"mord mathit\" style=\"margin-right:0.01968em;\">l</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span></span></span></span></li>\n</ul>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://www.zhihu.com/question/36132386/answer/530313852\">二分查找有几种写法？它们的区别是什么？ - Jason Li的回答 - 知乎</a></li>\n<li><a href=\"https://jingyuexing.github.io/Ebook/Algorithm/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA.pdf\">算法导论</a></li>\n</ul>\n","title":"理解二分搜索的上下界问题","date":"2023-11-10","description":"尽管二分查找的基本思想相对简单，但细节可以令人难以招架..."}},"__N_SSG":true}